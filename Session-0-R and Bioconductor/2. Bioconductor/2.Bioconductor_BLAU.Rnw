\documentclass{beamer}
%\usepackage{BioconductorSlides}

\usepackage[utf8]{inputenc}
\usepackage{graphicx}
%\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amsfonts,textcomp,setspace,graphicx,tikz,color}
\usepackage[absolute,overlay]{textpos}
  \setlength{\TPHorizModule}{1mm}
  \setlength{\TPVertModule}{1mm}
  
\AtBeginDocument{
\DefineVerbatimEnvironment{Sinput}{Verbatim} {xleftmargin=1em,fontsize=
\tiny}
\DefineVerbatimEnvironment{Soutput}{Verbatim}{xleftmargin=1em,fontsize=
\tiny}
\DefineVerbatimEnvironment{Scode}{Verbatim}{xleftmargin=1em,fontsize=
\tiny}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%   MODIFICAR AQUESTA SECCIÓ      %%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\title{Bioconductor packages for short read analyses}

\author{Alex S\'anchez}
\institute[UEB]{Unitat d'Estadística i Bioinformàtica (UEB)\\
  	}
\date{\today}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\include{macros}


\begin{document}
\SweaveOpts{concordance=TRUE}

\begin{frame}[plain]
%\addtocounter{totalframenumber}{-1}
\titlepage
\end{frame}

\begin{frame}[Frame 1]
\addtocounter{framenumber}{-1}
\frametitle{Table of Contents}
\tableofcontents
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%      MODIFICAR A PARTIR D'AQUI       %%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{General Information}

\subsection{Objectives}

\begin{frame}
\frametitle{Foreword}
  \bit
      \item The ``core'' packages for integrating NGS data anlysis represents a massive structure.
      \item It is under very active development and often different ways exist to achieve one goal.
	      \bit
	          \item \emph{e.g RangedData vs. GRanges}
	      \eit
      \item The trunk of this core starts to reach maturity and redundant branches might be pruned.
  \eit
\end{frame}


%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}
\frametitle{ALM}
 \bit
      \item Introduce all the necessary packages to perfom the QA and the pre-processin of NGS rawdata:
        \bit
	          \item\textbf{biomRt}
	          \item\textbf{rtracklayer}
	          \item\textbf{Biostrings}
	          \item\textbf{BSgenome}
	          \item\textbf{GenomicFeatures}
	          \item\textbf{GenomicRanges}
	          \item\textbf{IRanges}
	          \item\textbf{Rsamtools}
	          \item\textbf{ShortRead}  
        \eit
 \eit
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}
\frametitle{Before we ``really'' start: the Classes in R}
 \bit
      \item Two kinds: S3 and S4
        \bit
	          \item S3 are old and informal, setting the class attribute is enough to ``convert'' an object into a class
	          \item S4 is an attempt at making R more object oriented
	            \bit
		              \item they have specific definitions
		              \item they define ``fields'' called ``\textbf{slots}''
		              \item they can inherit and be inherited from
		              \item they can have prototypes, validators
		              \item they can be virtual
		              \item etc.
	            \eit
	          \item Most of the classes described here are of S4 type, except when backward compatibility with the R core required otherwise
	          \item More information can be foun in the R help page: ?classRepresentation
       \eit
 \eit
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}[fragile]
\frametitle{Methods to browse S4 classes}
(Load the IRanges library to run the following example)
    \begin{uncoverenv}
<<>>=
require(IRanges)
?Classes
?Methods
getClass("RleList")
@
    \end{uncoverenv}
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}[fragile]
\frametitle{Methods to browse S4 classes}
 \begin{uncoverenv}
<<>>=
names(completeSubclasses(getClass("RleList")))
head(showMethods(classes="RleList",printTo=FALSE))
showMethods("values",includeDefs=TRUE)
@
  \end{uncoverenv}
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}
\frametitle{Packages dependencies}
 \bit
    \item Sometimes packages define the same function resulting in one of the function to be inaccessible anymore.
    \item When this happens, one needs to contact the packages authors for them to find an appropiate solution
    \item In the meanwhile, the hack described on the next slides might help
    \item load the GenomicRanges and the genomeIntervals in that order
 \eit
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}
\frametitle{Packages dependencies}
 \bit
    \item For the purpose og the example it is not necessary to 
    understand the actual obects taht are created. We'll come back to them later.
    \item Create the necessary object
      \bit
	  \item \small{grngs $<-$ GRanges (seqnames=c(``chr1'',``chr2'',``ch31''), 
	  ranges=IRanges(start=c(3,4,1),end=c(7,5,3)),s
	  trand=c(``+'',``+'',``\--''), seqlegths=c(``chr1''=24,``chr2''=18))}
      \eit
 \eit
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}
\frametitle{Bottom - up approach}
\begin{figure}[ht]
\centering
\includegraphics[width=80mm]{diagramas/Seleccio_001.png}
\end{figure}
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}
\frametitle{Infrastructure package}
 \bit
      \item \textbf{IRanges}
        \bit
	          \item Long sequences, compressed and pointer referenced
	          \item \textbf{Views} on long sequences
	          \item Integer overlap tppñs; e.g. interval overlap
	          \item Used to define genomic intervals (i.e. RangedData)
        \eit
      \item \textbf{GenomicRanges} \hspace{4.1cm} \fbox{ Recent }
        \bit
	          \item IRanges extension 
	          \item Adds discontiguous genomic interval sets (useful for gapped alignments)
        \eit
      \item \textbf{genomeIntervals} \hspace{4cm} \fbox{ Not Core}
        \bit
	          \item Very similar to IRanges  
	          \item Extremely efficient at interval calculations; e.g. interval overlap
        \eit
 \eit
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}
\frametitle{Infrastructure Views}
 \bit
    \item Issue
      \bit
	  \item DNA sequences can be very large (think of the human genome)
	  \item Duplicating them in memory is contra-efficient
      \eit
     \item Therefore the views!
      \bit
	  \item Views is yet another IRanges class
	    \bit
		      \item a virtual class for storin set of views (~pointers) on a single Sequence object
		      \item avaliable as RleViews, XStringViews, XIntegerViews, XStringSetViews, etc.
		      \item it stores the sequence using a ``pass-by-reference'' semantic and associatesranges to select the subsequences
	    \eit
      \eit
 \eit
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}
\frametitle{Infrastructure Running Length Encodings (RLEs)}
 \bit
    \item Issue
      \bit
	  \item Again, memory is the limit. holding a  coverage vector at a single bp resolution is inefficient.
      \eit
     \item Therefore the concept of RLEs
      \bit
	  \item a common compression technique for piecewise constant data
	    \bit
		\item 0 0 0 1 1 1 2 2 3 3 3 ... can be compressed in
		\item 0(3), 1(3), 2(2), 3(3),...
	    \eit
	   \item it couples values e.g. 0 with a run length i.e. 3
	   \item Can be partitioned into RleList, e.g. for storing the coverage of different chromosomes
      \eit
 \eit
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}[fragile]
\frametitle{Infrastructure methods}
 \bit
    \item get the metods for the Rle S4 class
      \bit
	  \item f.list$<-$showMethods(classes=``Rle'', printTo=FALSE) 
      \eit
     \item process the result to extract the function name
      \bit
	  \item sapply(strsplit(f.list[grep(``Function'',f.list,''), function(l){gsub('\:',``,l[[2]])}
      \eit
 \eit
\bB{ \textbf{\emph{This return 111 methods!}} }
      \begin{uncoverenv}
<<>>=
f.list<-showMethods(classes="Rle", printTo=FALSE)
length(sapply(strsplit( f.list[grep("Function",
  f.list)],' '),function(l){gsub('\"|:','',l[[2]])}))
@
 \end{uncoverenv}
    \eB
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}
\frametitle{Infrastructure methods, some examples}
 \bit
    \item \textbf{Arithmetic}  $+,-,*,^,\%\%,\% /\%,/$
    \item \textbf{Compare}
    $==,>,<,!=,<=,>=$
    \item \textbf{Logic}
    $\& ,| $
    \item \textbf{Math}
    abs, sign, sqrt, ceiling, floor, trunc, cummax, cummin, cumprod, cumsum, log, log10, log2, log1p, acos, acosh, asin, asinh,...
    \item \textbf{Math2}
    round,signif
    \item \textbf{Summmary}
    max, min, range, prod, sum, any, all
 \eit
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}
\frametitle{Looks intimidating}
 \bit
    \item Still the point is:
      \bit
	        \item whenever you think about a functionality, it probably already exists.
      \eit
 \eit

\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}[fragile]
\frametitle{Example 1: coverage}
  \bit
      \item Coverage calculation
  \eit
  \begin{uncoverenv}
<<eval=FALSE>>=
require("ShortRead")
fl<-system.file("extdata","GSM424494_wt_G2_orc_chip_rep1_S288C_14.mapview.txt.gz",
                package="EatonEtAlChiPseq")
aln<-readAligned(fl,type="MAQMapview")
cover<-coverage(aln);cover
cover[["S288C_14"]]
head(runValue(cover[["S288C_14"]]))
as.integer(cover[["S288C_14"]])
smoothCover<-round(runmean(cover,75,endrule="constant"))
class(smoothCover)
smoothCover
@
 \end{uncoverenv}
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}[fragile]
\frametitle{Example 2: slice}
  \bit
      \item Finding wide regions with elevated coverage
  \eit
  \begin{uncoverenv}
<<eval=FALSE>>=
islands<-slice(smoothCover,lower=10)
islandsWithWidePeaks<- islands[vienMaxs(islands)>=20L &width(islands)>=500L]
islandsWithWidePeaks
@
 \end{uncoverenv}
  
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}
\frametitle{What comes on top of IRanges}
  \bit
      \item We've ``covered'' \textbf{IRanges} and it's low level capabilities.
      \item Still, High Throughput methods in biology, especially sequencing, are more about sequenes than maths.
      \item Therefor the \textbf{Biostrings} package, build on top of IRanges
        \begin{figure}[ht]
              \centering
              \includegraphics[width=50mm]{diagramas/Seleccio_004.png}
        \end{figure}
  \eit
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}[fragile]
\frametitle{Biostrings}
  \bit
      \item \small{All the classes in that package derivers from the XString class}
        \begin{uncoverenv}
<<>>=
require(Biostrings)
getClass("XString")
@
        \end{uncoverenv}
      \item There are 4 subclasses:
        \bit
            \item \small{\textbf{BString}: store strings without alphabet}
            \item \small{\textbf{DNAString}: store strings with an DNA alphabet}
            \item \small{\textbf{RNAString}: store strings with an RNA alphabet}
            \item \small{\textbf{AAString}: store strings with an Amino Acid alphabet}
        \eit
  \eit
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}[fragile]
\frametitle{An DNAString example}
  \bit
      \item The \textbf{Biostring} package contains many example datasets
            \begin{uncoverenv}
<<>>=
data(package="Biostrings")
data(yeastSEQCHR1)
class(yeastSEQCHR1)
nchar(yeastSEQCHR1)
DNAString(yeastSEQCHR1)
@
            \end{uncoverenv}
      \item The obtained DNAString is defined by the DNA alphabet
            \begin{uncoverenv}
<<>>=
alphabet(DNAString(yeastSEQCHR1))
@
            \end{uncoverenv}
  \eit
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}[fragile]
\frametitle{The alphabets}
  \bit
      \item The \textbf{Biostring} package implements the possible alphabets
        \begin{uncoverenv}
<<>>=
GENETIC_CODE
AMINO_ACID_CODE
RNA_GENETIC_CODE
IUPAC_CODE_MAP
@
        \end{uncoverenv}
  \eit
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}[fragile]
\frametitle{Set of Strings}
  \bit
      \item XStrings and subclasses instanves can all be grouped into Sets
        \begin{uncoverenv}
<<>>=
names(completeSubclasses(getClass("XStringSet")))
@
        \end{uncoverenv}  
      \item Again, there are data examples withun the \textbf{Biostring} package to play with
          \begin{columns}
            \begin{column}[t]{0.45\textwidth}%
                \begin{uncoverenv}
<<>>=
data(srPhiX174)
class(srPhiX174)
@
                \end{uncoverenv}  
            \end{column}
            \begin{column}[t]{0.70\textwidth}%
                \begin{uncoverenv}
<<>>=
head(srPhiX174)
@
                \end{uncoverenv}  
            \end{column}
          \end{columns}
  \eit
\end{frame}


%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}
\frametitle{XString Methods}
  \bit
      \item Basic utilities
        \bit
            \item subsequence selection
              \bit
                  \item subseq, Views, narrow (XStringSet, IRanges package)
              \eit
            \item letter frequencies
              \bit
                  \item alphabetFrequency, dinucleotideFrequency (tri..., oligo...), uniqueLetters
              \eit
            \item letter consensus
              \bit
                  \item consensusMatrix,consensusString
              \eit 
            \item letter transformation
              \bit
                  \item reverse, complement, reverseComplement, translate, chartr
              \eit
            \item Input/Output
              \bit
                  \item read.DNAStringSet (...B...,...RNA...,..AA..)
                  \item write.XStringSet, save.XStringSet
              \eit
        \eit
  \eit
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}
\frametitle{Xstrings Methods (c'ed)}
  \bit
      \item Advanced
        \bit
            \item \textbf{alignment utilities}:pairwiseAlignment, stringDist
            \item \textbf{string matching}
              \bit
                  \item (v)matchPDict ( on a reference or a reference set (v))
                    \bit
                        \item (v)matchPDict, (v)countPDict,(v)whichPDict
                    \eit
                  \item matchPattern
                    \bit
                        \item(v)matchPattern,(v)countPattern, neditStartingAt, neditEndingAt, (which.) isMatchingStartingAt, (which.)isMatchingEndingAt
                    \eit
                  \item matchPWM(Position Weight Matrix, e.g. for transcription factor binding sites)
                    \bit
                        \item matchPWM,countPWM
                    \eit
              \eit
            \item \textbf{Others}
              \bit
                  \item matchLRPatterns, trimLRPatterns,matchProbePair, findPalindromes, findComplementedPalindromes
              \eit
            
        \eit
  \eit
\end{frame}
%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}[fragile]
\frametitle{Example 1: Letter/ alphabet frequencies}
  \bit
      \item \small{Single-letter frequencies}
        \begin{uncoverenv}
<<>>=
alphabetFrequency(DNAString(yeastSEQCHR1))
alphabetFrequency(DNAString(yeastSEQCHR1),baseOnly=TRUE)
@
        \end{uncoverenv}  
      \item \small{Multi-letter frequencies}
       \begin{uncoverenv}
<<>>=
dinucleotideFrequency(DNAString(yeastSEQCHR1))
head(trinucleotideFrequency(DNAString(yeastSEQCHR1)),20)
head(trinucleotideFrequency(DNAString(yeastSEQCHR1),6),14)
@
        \end{uncoverenv} 
  \eit
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}[fragile]
\frametitle{Example 2: String manipulation}
  \bit
      \item Standard transformations
        \begin{columns}
          \begin{column}[t]{0.45\textwidth}%
            \begin{uncoverenv}
<<>>=
head(narrow(srPhiX174,1,9))
head(reverse(narrow(srPhiX174,1,9)))
@
            \end{uncoverenv} 
          \end{column}
      
          \begin{column}[t]{0.50\textwidth}%
            \begin{uncoverenv}
<<>>=
head(reverseComplement(narrow(srPhiX174,1,9)))
head(translate(narrow(srPhiX174,1,9)))
@
            \end{uncoverenv} 
          \end{column}
        \end{columns} 
  \eit
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}[fragile]
\frametitle{Example 2: String manipulation}
  \bit
      \item Bisulffite transformation
          \begin{uncoverenv}
<<>>=
alphabetFrequency(chartr("C","T", DNAString(yeastSEQCHR1)),baseOnly=TRUE)
alphabetFrequency(DNAString(yeastSEQCHR1),baseOnly=TRUE)
@
          \end{uncoverenv} 
  \eit
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}[fragile]
\frametitle{Example 3: Consensus}
  \bit
      \item Consensus matrix
           \begin{uncoverenv}
<<>>=
snippet<-subseq(head(sort(srPhiX174),5),1,10);snippet
consensusMatrix(snippet,baseOnly=TRUE)
@
            \end{uncoverenv}
      \item Consensus string
           \begin{uncoverenv}
<<>>=
consensusString(snippet)
consensusString(snippet,ambiguity="N",threshold=0.5)
?consensusString
@
          \end{uncoverenv}
  \eit
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}[fragile]
\frametitle{Example 4: String Matching}
  \bit
      \item Match counting
          \begin{uncoverenv}
<<>>=
data(phiX174Phage)
phiX174Phage
genome<- phiX174Phage[["NEB03"]]
negPhiX174<- reverseComplement(srPhiX174)
posCounts<- countPDict(PDict(srPhiX174),genome)
negCounts<- countPDict(PDict(negPhiX174),genome)
table(posCounts,negCounts)
@
          \end{uncoverenv}
  \eit
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}
\frametitle{Example 4: String Matching}
  \bit
      \item So we have 1030 reads that do not align either way to the genome and only 83 aligning.
      \item The match locations can be found using:
          \begin{uncoverenv}
<<>>=
matchPDict(PDict(srPhiX174[posCounts>0]),genome)
@
          \end{uncoverenv}
  \eit
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}[fragile]
\frametitle{Example 5: Pairwise alignment}
  \bit
      \item alignment scores
           \begin{uncoverenv}
<<>>=
posScore <- pairwiseAlignment(srPhiX174, genome, type="global-local", scoreOnly=TRUE)
negScore <- pairwiseAlignment(negPhiX174, genome, type="global-local", scoreOnly=TRUE)
which(pmin(posScore)<pmin(negScore))
@
          \end{uncoverenv}
      \item alignment
        \begin{uncoverenv}
<<>>=
pairwiseAlignment(srPhiX174[932],genome,type="global-local")
pairwiseAlignment(negPhiX174[932],genome,type="global-local")
@
        \end{uncoverenv}
  \eit
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}
\frametitle{What next?}
  \bit
      \item We now have seen how to deal with biologically meaningful intervals and objects.
      \item Many organism have been sequenced and their genome is know.
      \item An interface in R to easily acces and manipulate such information would be very useful; this is the \textbf{BSgenome} package.
  \eit
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}
\frametitle{BSgenome}
  \bit
      \item It is not just a data package; it leverages th functionalitis introduced in \textbf{Biostrings}
            \begin{figure}[ht]
              \centering
              \includegraphics[width=70mm]{diagramas/Seleccio_005.png}
            \end{figure}
  \eit
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}[fragile]
\frametitle{Available genomes}
  \bit
      \item Easy to find out
          \begin{uncoverenv}
<<>>=
require(BSgenome)
head(available.genomes())
@
          \end{uncoverenv}
      \item However, large genomes(i.e. human, mouse, ... ) packages might take log to transfer.
  \eit
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}[fragile]
\frametitle{BSgenome Class overview (c'ed)}
  \begin{columns}
  \begin{column}[t]{0.45\textwidth}%
  \bit
      \item Important:
        \bit
            \item proper S4 class usage ban accessing a slot through the ``@'' accessor, except within a package scope.
            \item Hence, it is nowhere to be seen on the present slide
        \eit
  \eit
  \end{column}
    
  \begin{column}[t]{0.45\textwidth}%
        \begin{uncoverenv}
<<>>=
library(BSgenome.Dmelanogaster.UCSC.dm3)
# Dmelanogaster@seqs_dir
#Dmelanogaster@masks_dir    ERROR
#dir(Dmelanogaster@masks_dir)
@
        \end{uncoverenv}
  \end{column}
  \end{columns}
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}
\frametitle{BSgenome methods}
  \bit
      \item \textbf{Sequence selection}: $[[,\$ $
      \item \textbf{Subsequence selection}: getSeq
      \item \textbf{Accesors}: length, names/seqnames, mseqnames, seqlengths, masknames, sourceUrl
      \item \textbf{Matching}: all Biostings methods
      \item \textbf{SNPs}: injectSNPs, SNPlocs_pkgname,SNPcount, SNPlocs
  \eit
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}[fragile]
\frametitle{Sequence information}
  \bit
      \item operation that do not load sequences
        \begin{uncoverenv}
<<>>=
require(BSgenome.Dmelanogaster.UCSC.dm3)
head(seqnames(Dmelanogaster))
head(seqlengths(Dmelanogaster))
@
        \end{uncoverenv}
      \item operation that do
        \begin{uncoverenv}
<<>>=
alphabetFrequency(Dmelanogaster[["chr4"]],baseOnly=TRUE)
@
        \end{uncoverenv}      
  \eit
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}[fragile]
\frametitle{Masked vs unmasked}
  \begin{column}[t]{1\textwidth}%
  \bit
      \item unmasked package
        \bit
            \item e.g Dmelanogaster
        \eit
      \item masked packages
        \bit
            \item e.g Hsapiens
        \eit
  \eit
        \begin{uncoverenv}
<<>>=
library(BSgenome.Hsapiens.UCSC.hg19)
Hsapiens[["chr1"]]
@
        \end{uncoverenv}   
  \end{column}
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}[fragile]
\frametitle{Extending Biostrings. Example 1}
  \bit
      \item Applying the Biostrings matching functions:
         \begin{uncoverenv}
<<>>=
exclude<-setdiff(seqnames(Hsapiens),c("chr1","chr2"))
vcountPattern("ACYTANCAGT", Hsapiens, fixed=c(pattern=FALSE, subject=TRUE), exclude=exclude)
#vmatchPattern("ACYTANCAGT",Hsapiens, fixed=c(pattern=FALSE, subject=TRUE), exclude=exclude, 
#asRangedData=FALSE)
@
        \end{uncoverenv}   
  \eit
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}[fragile]
\frametitle{Example 2}
  \begin{column}[t]{1\textwidth}%
          \bit
              \item Using a Pattern Dictionary, e.g. a library of microarray probes
          \eit
        \begin{uncoverenv}
<<>>=
library(hgu95av2probe)
probes<-DNAStringSet(hgu95av2probe$sequence[1:100])
probes[1:10]
@
        \end{uncoverenv}   
  \end{column}
\end{frame}
%--------------------------------------------------------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Example 2}
  \begin{column}[t]{1\textwidth}%
        \begin{uncoverenv}
<<>>=
counts<-vcountPDict(probes,Hsapiens,exclude=exclude);counts
#whichMatch<-seqselect(counts$index,counts$count>0);whichMatch  No existeix seqselect!!
#matchedProbes<- probes[WhichMatch];matchedProbes
#matchLocs<-matchPDict(PDict(matchedProbes),Hsapiens$chr2);matchLocs
#extractAllMatches(Hsapiens$chr2,matchLocs)
@
        \end{uncoverenv}   
  \end{column}
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}[fragile]
\frametitle{Example 5}
  \bit
      \item A new interesting feature is the possibility to inject SNPs!
  \eit
        \begin{column}[t]{0.45\textwidth}%
        \begin{uncoverenv}
<<>>=
cat(available.SNPs(),sep="\n")
library("SNPlocs.Hsapiens.dbSNP.20090506")
HsWithSNPs<-injectSNPs(Hsapiens,
          "SNPlocs.Hsapiens.dbSNP.20090506")


@
        \end{uncoverenv}   
        \end{column}
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Example 5}
\begin{column}[t]{1\textwidth}%
        \begin{uncoverenv}
<<>>=
HsWithSNPs
#SNPlocs_pkgname(HsWithSNPs)
#SNPcount(HsWithSNPs)
#alphabetFrequency(Hsapiens$chr1)
#alphabetFrequency(HsWithSNPs$chr1)
@
        \end{uncoverenv}   
        \end{column}
\end{frame}
%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}[fragile]
\frametitle{What next?}
\begin{column}{1\textwidth}
  \bit
      \item Now that we can acces genomic information, it would be useful to import the related annotation. That's (one of) the purpose of the following packages:
        \bit
            \item \textbf{rtracklayer}
            \item \textbf{GenomicFeatures}
            \item \textbf{biomaRt}
            \item \textbf{genomeIntervals}
        \eit
      \item \textbf{rtracklayer} offers export function too and as alredy presented, \textbf{genomeIntervals} offers interval utilities similar to \textbf{IRanges}
  \eit
\end{column}
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}
\frametitle{rtracklayer}
    \begin{figure}[ht]
    \centering
    \includegraphics[width=60mm]{diagramas/Seleccio_006.png}
    \end{figure}
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}
\frametitle{Methods}
\begin{column}{1\textwidth}
  \bit
      \item There are two high level methods 
        \bit
            \item import
            \item export
        \eit
      \item Both accept the following formats:
        \bit
            \item BED: bed, bedGraph, bed15
            \item GFF: gff1, 2 and 3
            \item WIG
        \eit
      \item export works with \emph{RangedData} objects
      \item import returns a \emph{RangedData} object or \emph{GRanges} object, depending on the (asRangedData) boolean argument.
  \eit
\end{column}
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}
\frametitle{Methods (c'ed)}
\begin{column}{1\textwidth}
  \bit
      \item When exporting
        \bit
            \item The naming convention of the \emph{RangedData} column names is crucial.
            \item The following column names 
              \bit
                  \item \textbf{names}: for exporting the feature names
                  \item \textbf{scores}: for exporting the feature scores
                  \item \textbf{strand}: for exporting the feature strands
                  \item \textbf{see} ?export.bed for the complete  details
              \eit
        \eit
  \eit
  \end{column}
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}
\frametitle{GenomicFeatures}
\begin{column}{1\textwidth}
  \bit
      \item manegement of transcript information
        \bit
            \item using \textbf{GenomicRanges}
            \item stored into SQLite databases
        \eit
      \begin{figure}[ht]
      \centering
      \includegraphics[width=40mm]{diagramas/Seleccio_007.png}
      \end{figure}
  \eit
  \end{column}
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}[fragile]
\frametitle{Constructors and Class}
  \bit
      \item makeTranscriptDbFromBiomart
      \item makeTrascriptDbFromUCSC
          \begin{uncoverenv}
<<>>=
library(GenomicFeatures)
head(supportedUCSCtables())
mm9KG<-makeTranscriptDbFromUCSC(genome="mm9",tablename="knownGene")
saveFeatures(mm9KG,file="mm9KG.sqlite")
@
          \end{uncoverenv}   
  \eit
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Constructors and Class}
          \begin{uncoverenv}
<<>>=
mm9KG<-loadFeatures("mm9KG.sqlite")
mm9KG
@
          \end{uncoverenv}   
\end{frame}
%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}
\frametitle{Extractors}
\begin{column}{1\textwidth}
  \bit
      \item ungrouped
        \bit
            \item transcriptBy
            \item exonsBy
            \item intronsByTranscript
            \item fiveUTRsByTranscript
            \item threeUTRsByTranscript
        \eit
  \eit
\end{column}
\end{frame}
  
%--------------------------------------------------------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{Extractors}
     \begin{uncoverenv}
<<>>=
library(GenomicFeatures)
txExons<-exonsBy(mm9KG)
head(txExons)

@
      \end{uncoverenv}   
\end{frame}
  



%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}
\frametitle{Usage}
\begin{column}{1\textwidth}
  \bit
      \item Overlapping with transcripts
        \bit
            \item findOverlaps
            \item countOverlaps
            \item match
            \item \%in\%
            \item subsetByOverlaps
        \eit
      \item More about these in the following part about \textbf{GenomicRanges}
  \eit
\end{column}
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}
\frametitle{biomaRt}
\begin{column}{1\textwidth}
  \bit
      \item Side note to get help from within R:
        \bit
            \item vignette(``biomaRt'',package=``biomaRt'')
        \eit
      \item biomaRt is an interface to the collection of databases that implements the bioMart software suite:
        \bit
            \item \url{http://biomart.org}
            \item allow retrieval og huge datasets from different sources through a common interface
            \item examples are: Ensembl, HapMap, Uniprot, ...
        \eit        
  \eit
\end{column}
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}[fragile]
\frametitle{biomaRt, an example}
\begin{column}{1\textwidth}
  \bit
      \item Connect the mart database
          \begin{uncoverenv}
<<>>=
require(biomaRt)
ensembl<- useMart("ensembl")
head(listDatasets(ensembl))
ensembl<- useMart("ensembl",dataset="dmelanogaster_gene_ensembl")
head(listAttributes(ensembl))
@
          \end{uncoverenv}   
  \eit
\end{column}
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}[fragile]
\frametitle{biomaRt, an example (c'ed)}
\begin{column}{1\textwidth}
  \bit
      \item   query the database
          \begin{uncoverenv}
<<eval=FALSE>>=
exon.annotation<-getBM(c("ensemb_gene_id","strand",
                "chromosome_name","ensembl_exon_id",
                "exon_chrom_start","exon_chrom_end"),
                mart=ensembl,filters="chromosome_name",
                values="4")
@
          \end{uncoverenv}   
    \item convert into a RangedData / Granges
  \eit
\end{column}
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}
\frametitle{genomeIntervals}
\begin{column}{1\textwidth}
  \bit
      \item   Similar interval implementation to IRanges
        \bit
            \item (+) overall faster, gff function more robust to 'incorrect' format
            \item (-) less integrated in R
        \eit
      \item Two classes:
        \bit
            \item Genome\_intervals
            \item Genome\_intervals\_stranded
        \eit
      \item Methods
        \bit
            \item input
              \bit
                  \item \textbf{ readGff3, getGffAttributes}, parseGffAttributes
              \eit
            \item intervals utilities
              \bit
                  \item interval\_overlap, \textbf{interval\_complement}, interval\_union, interval\_intersection
              \eit
        \eit
  \eit
\end{column}
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}
\frametitle{What next?}
\begin{column}{1\textwidth}
  \bit
      \item We have seen how to get genomic sequences and their annotation
      \item For processing NGS data, we are now missing the other half of the workflow: loading and manipulating the actual data. For this, three packages are available.
        \bit
            \item \textbf{GenomicRanges}
            \item \textbf{Rsamtools}
            \item \textbf{ShortRead}
        \eit
  \eit
\end{column}
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}
\frametitle{GenomicRanges}
\begin{column}{1\textwidth}
    \begin{figure}[ht]
    \centering
    \includegraphics[width=80mm]{diagramas/Seleccio_008.png}
    \end{figure}
\end{column}
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}
\frametitle{Naive approach}
\begin{column}{1\textwidth}
  \bit
      \item   Genomic coordinates consist of
        \bit
            \item chromosome 
            \item position
            \item strand
            \item additional information
              \bit
                  \item GC content
                  \item etc.
              \eit
        \eit
      \item This caan be represented by a data.frame
        \bit
            \item fine for organism information ($\sim$ 100k exons, 20k genes)
            \item not for million of reads 
        \eit
  \eit
\end{column}
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}
\frametitle{BIOC representation for intervals with data}
\begin{column}{1\textwidth}
  \bit
      \item \emph{RangedData}
        \bit
            \item used by \textbf{rtracklayer}
            \item interval grouped by chromosome/conting
            \item strand unaware
        \eit
      \item \emph{GRanges}
        \bit
          \item used by \textbf{GenomicFeatures}
          \item intervals not required to be grouped by chromosome/contig
          \item strand aware
          \item \emph{GRangesList} can hold exons with spliced transcripts 
        \eit
  \eit
\end{column}
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}[fragile]
\frametitle{GRanges constructor and slots}
\begin{column}{1\textwidth}
  \bit
      \item starts and ends defined in an \emph{IRanges} object
      \item strand, seqnames (chromosome) and seqlenghts (chromosome size) to be provided
          \begin{uncoverenv}
<<>>=
grngs<-GRanges(seqnames=c("chr1","chr2","chr1"), 
      ranges=IRanges(start=c(3,4,1),end=c(7,5,3)),
    strand=c("+","+","-"),seqlengths = c("chr1"=24,"chr2"=18))
grngs
@
          \end{uncoverenv}   
      \item additional slots can contain mtadata information
          \begin{uncoverenv}
<<>>=
getSlots("GRanges")
@
          \end{uncoverenv}  
  \eit
\end{column}
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}
\frametitle{Interval operations}
\begin{column}{1\textwidth}
  \bit
      \item Intra-interval
        \bit
            \item flank,resize,shift
        \eit
      \item Inter-interval
        \bit
            \item disjoin, gaps, reduce, range
            \item coverage
        \eit
      \item Between intervals sets
        \bit
            \item union, intersect, setdiff
            \item punion,pintersectm psetdiff
            \item findOverlaps, countOverlaps, \%in\%, match
        \eit
      \item Low Level
        \bit
            \item start,end,width
        \eit
  \eit
  \end{column}
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}[fragile]
\frametitle{Other functions}
\begin{column}{1\textwidth}
  \bit
      \item Selecting
        \bit
            \item seqselect, [
            \item head, tail, window
            \item subset, subsetByOverlaps
                     \begin{uncoverenv}
<<>>=
grngs[strand(grngs)== "-"]
# seqselect(grngs,strand(grngs)=="-") NO EXISTEIX seqselect
@
        \end{uncoverenv}  
        \eit
  \eit
  \end{column}
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}[fragile]
\frametitle{Example 1: Intra-interval}
\begin{columns}

\begin{column}{0.45\textwidth}
  \bit
      \item shift
           \begin{uncoverenv}
<<>>=
grngs
shift(grngs,1)
@
        \end{uncoverenv}  
  \eit
  \end{column}
  
  \begin{column}{0.55\textwidth}
  \bit
      \item resize
           \begin{uncoverenv}
<<>>=
resize(grngs,10)
@
        \end{uncoverenv} 
      \item flank
           \begin{uncoverenv}
<<>>=
flank(grngs,2)
@
        \end{uncoverenv}  
  \eit
  \end{column}
  
\end{columns}
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}[fragile]
\frametitle{Overlap detection}
\begin{column}{1\textwidth}
  \bit
      \item \emph{findOverlap} and \emph{countOverlaps} produce a mapping and a tabulation of interval overlaps, respectively
            \begin{uncoverenv}
<<>>=
ol<-findOverlaps(grngs,reduce(grngs))
ol
@
        \end{uncoverenv}       
  \eit
  \end{column}
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}
\frametitle{Rsamtools}
Blue represents the ''+'' strand, red the''-'' strand
 \begin{figure}[ht]
    \centering
    \includegraphics[width=100mm]{diagramas/Seleccio_009.png}
  \end{figure}
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}
\frametitle{samtools and Rsamtools}
\begin{column}{1\textwidth}
  \bit
      \item samtools
        \bit
            \item Data Format: SAM(text) and BAM (binary)
            \item Tools: merge, sort, pileup, view, etc.
        \eit
      \item Rsamtools
        \bit
            \item Reads and represents BAMfiles
            \item high level: readAligned (type=BAM), readPileup
            \item lower level: scanBam, scanBamParam, ScanBamWhat
            \item utilities: countBam, sortBam, indexBam, filterBam, scanBamHeader
            \item views: BamViews
        \eit
  \eit
  \end{column}
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}[fragile]
\frametitle{Input}
\begin{column}{1\textwidth}
  \bit
      \item   \small{readAligned} returns an \emph{alignedRead} class
        \bit
            \item described in the following section on \textbf{ShortRead}
        \eit
      \item \small{scanBam} returns a list of list i.e.. one list per column in the SAM file.
        \bit
            \item qname: a \emph{BStringSet} containing the read id 
            \item seq: a \emph{DNAStringSet} containing the read sequence
            \item etc.
            \item The possible fields can be found with \small{scanBamWhat()}
              \begin{uncoverenv}
<<>>=
require(Rsamtools)
scanBamWhat()
@
        \end{uncoverenv}    
        \eit
      \item \small{scanBam} is the function called by the \textbf{GenomicRanges} \small{readGappedAlignments} method
  \eit
  \end{column}
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}[fragile]
\frametitle{Input (c'ed)}
\begin{column}{1\textwidth}
  \bit
      \item   The input can be controlled using \small{ScanBamParam}
        \bit
            \item it has three fields
              \bit
                  \item \textbf{which}: \emph{GRanges} selecting references, genomic loci, strand, ...
                    
                  \item \textbf{flag}: use the SAM flag to selected paired, mapped, etc. reads.
                        \begin{uncoverenv}
<<>>=
names(formals(scanBamFlag))
@
                        \end{uncoverenv}    
                  \item \textbf{what}: fields to retrieve (cf. \small{scanBamWhat})
              \eit
        \eit
  \eit
  \end{column}
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}
\frametitle{GappedAlignments vs AlignedRead}
\begin{column}{1\textwidth}
  \bit
      \item \emph{AlignedRead}
        \bit
            \item reads complete files
            \item include sequence, quality, identifier, etc.
            \item reads are assumed to be ungapped
        \eit
      \item \emph{GappedAlignments}
        \bit
            \item use scanBam
            \item genomic coordinates, 'cigar', covered intervals
            \item Cigar: an RLE; M(match), I (insertion), D (deleiton), N (skipped), P (padding), S/H (soft/hard clip)
            \item direct IRanges accesors (sub-setting, narrowing, coverage)
        \eit
  \eit
  \end{column}
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}
\frametitle{BamViews}
\begin{column}{1\textwidth}
  \bit
      \item Acces a set of experiments stored in BAM files
        \bit
            \item for example to query a specific loci
        \eit 
      \item Check the vignette ("leeViews")
      \item Still very unstable!
  \eit
  \end{column}
  
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}[fragile]
\frametitle{BamViews}
  \begin{column}{1.3\textwidth}
                        \begin{uncoverenv}
<<>>=
library(leeBamViews)
bpaths=dir(system.file("bam",package="leeBamViews"),full=TRUE, patt="bam$")
gt<- do.call(rbind, strsplit(basename(bpaths),"_"))[,1]
geno<-substr(gt,1,nchar(gt)-1)
lane<- substr(gt,nchar(gt),nchar(gt))
pd=DataFrame(geno=geno, lane=lane, row.names=paste(geno,lane,sep="."))
bs1=BamViews(bamPaths=bpaths, bamSamples=pd, bamExperiment=list(annotation="org.Sc.sgd.db"))
bamPaths(bs1)
@
                        \end{uncoverenv}    
  \end{column}
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------
\begin{frame}[fragile]
\frametitle{BamViews}
  \begin{column}{1.3\textwidth}
                        \begin{uncoverenv}
<<>>=
bamSamples(bs1)
sel<-GRanges(seqnames="Scchr13",IRanges(start=861250,end=863000),strand="+")
# covex=RleList(lapply(bamPaths(bs1),function(x) coverage(readGappedAlignments(x))[[1]]))
@
                        \end{uncoverenv}    
  \end{column}
\end{frame}


%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}
\frametitle{ShortRead}
\begin{column}{1\textwidth}
      \begin{figure}[ht]
      \centering
      \includegraphics[width=90mm]{diagramas/Seleccio_011.png}
      \end{figure}
  \end{column}
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}
\frametitle{ShortRead}
\begin{column}{1\textwidth}
  \bit
      \item Input
        \bit
            \item read most sequence proprietary formats
            \item read fastq
            \item read BAM
        \eit
      \item Exploration
        \bit
            \item contains sequence, quality, id, etc. information
        \eit
      \item Manipulation
        \bit
            \item allow the manipulation of the fields with a limited memory impact
        \eit
      \item Quality assessment
        \bit
            \item offers quality assessment functionalities
        \eit
  \eit
  \end{column}
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}[fragile]
\frametitle{AlignedReadClass}
\begin{column}{1\textwidth}
  \bit
      \item   The main class to store the read information
                     \begin{uncoverenv}
<<>>=
require(ShortRead)
showClass("AlignedRead")
@
                        \end{uncoverenv}  
      \item All slots can be accessed through accordingly named accessors
  \eit
  \end{column}
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame} [fragile]
\frametitle{SRFilterclass}
\begin{column}{1\textwidth}
  \bit
      \item \small{Useful tools to filter the reads during or after the import}
      \begin{uncoverenv}
<<>>=
showClass("SRFilter")
@
       \end{uncoverenv}  
       \item \small{many already implemented}
        \bit
            \item \tiny{idFilter}
            \item \tiny{chromosomeFilter}
            \item \tiny{positionFilter}
            \item \tiny{strandFilter}
            \item \tiny{etc.}
        \eit
      \item \small{They can be combined using compose}
        \bit
            \item \small{compose(idFilter,chromosomeFilter)}
        \eit
  \eit
  \end{column}
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}[fragile]
\frametitle{Other classes}
\begin{column}{1\textwidth}
  \bit
      \item The package implements many classes to hold the different kind of data
            \begin{uncoverenv}
<<>>=
getClasses(where="package:ShortRead")
@
       \end{uncoverenv} 
  \eit
  \end{column}
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}[fragile]
\frametitle{Input and accessor examples}
\begin{column}{1\textwidth}
  \bit
      \item Simple walk through
            \begin{uncoverenv}
<<>>=
require("EatonEtAlChIPseq")
fl<-system.file("extdata","GSM424494_wt_G2_orc_chip_rep1_S288C_14.mapview.txt.gz",
                package="EatonEtAlChIPseq")
aln<-readAligned(fl,type="MAQMapview");aln
head(sread(aln))
@
       \end{uncoverenv} 
  \eit
  \end{column}
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}[fragile]
\frametitle{Input and accessor examples}
\begin{column}{1\textwidth}
  \bit
       \item with filters
                   \begin{uncoverenv}
<<>>=
filter<- compose(chromosomeFilter("S288C_14"),positionFilter(min=1,max=1000))
alnF<-readAligned(fl,type="MAQMapview",filter=filter);alnF
@
       \end{uncoverenv} 
  \eit
  \end{column}
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------


\begin{frame}[fragile]
\frametitle{Input and accessor examples}
\begin{column}{1\textwidth}
      \begin{uncoverenv}
<<>>=
head(quality(aln))
head(id(aln))
@
       \end{uncoverenv} 
  \end{column}
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}[fragile]
\frametitle{Manipulation example}
\begin{column}{1\textwidth}
  \bit
      \item For example to rename chromosome
      \begin{uncoverenv}
<<>>=
chrom<-chromosome(alnF)
i<-sub("S288C_([[:digit:]]+)","\\1",levels(chrom));i
levels(chrom)
levels(chrom)<-paste("chr",as.roman(i),sep="")
levels(chrom)
alnF<-renew(alnF,chromosome=chrom);alnF

@
       \end{uncoverenv} 
  \eit
  \end{column}
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------


\begin{frame}[fragile]
\frametitle{Quality assessment}
\begin{columns}
\begin{column}{0.3\textwidth}
  \bit
      \item Many functions are available in \textbf{ShortRead} that can be used for performing QA
      \begin{uncoverenv}
<<>>=
f.list<-showMethods(
where="package:ShortRead",
printTo=FALSE)
@
       \end{uncoverenv}   
       \vspace{8cm}
  \eit
  \end{column}
  
  \begin{column}{0.65\textwidth}
      \begin{uncoverenv}
<<>>=
sapply(strsplit(f.list[grep("Function",f.list)],' '),
       function(x)x[2])
@
       \end{uncoverenv} 
  \end{column}
  \end{columns}
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}[fragile]
\frametitle{QA example (yet another one...)}
\begin{column}{1\textwidth}
  \bit
      \item   Using independent functions
      \begin{uncoverenv}
<<fig=TRUE,out.width=15>>=
abc<- alphabetByCycle(sread(alnF))
abc[1:4,1:12]
abc<-abc[1:4, ]
par(mfrow=c(1,2))
matplot(t(abc),type="l",lty=rep(1,4))
m<-as (quality(alnF),"matrix")
plot(colMeans(m),type="b")
@
       \end{uncoverenv} 
       \item All these and more are combined into the function: qa()
       \item These can then be reported using the report() function
  \eit
  \end{column}
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}
\frametitle{Conclusion}
\begin{column}{1\textwidth}
      \begin{figure}[ht]
      \centering
      \includegraphics[width=90mm]{diagramas/Seleccio_012.png}
      \end{figure}
  \end{column}
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}
\frametitle{Conclusion}
\begin{column}{1\textwidth}
  \bit
      \item We have seen the two ``branches'' of the core packages:
        \bit
            \item the one used to get genomic sequence and annotation
            \item the one used to load and manipulate NGS data
        \eit
      \item Actually, the cit is not so clear ad the packages of these two branches are interacting at different levels.
      \item They provide numerous functionalities and are getting into a ``production'' (stable development) state.
      \item Higher level packaages are being developed to wrap these functionalities into more user friendly packages.
  \eit
  \end{column}
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}
\frametitle{Conclusion}
\begin{column}{1\textwidth}
  \bit
      \item If you would start today using these packages:
        \bit
            \item go for the BAM format
            \item go for GRanges objects
            \item Be on the lookout, especially for the \emph{SummarizedExperiment} class in the \textbf{GenomicRanges} package.
              \bit
                  \item It is a concept similar to the \emph{ExpressionSet} class devoloped for microarray and aims at normalizing the output of NGS experiments within R/Bioconductor
              \eit
        \eit
  \eit
  \end{column}
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}
\frametitle{If we were fast..}
\begin{column}{1\textwidth}
  \bit
      \item Another couple of package to mention
        \bit
            \item Rsubread (only on linux)
            \item easyRNASeq (self-promotion)
        \eit
  \eit
  \end{column}
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}[fragile]
\frametitle{Rsubread}
\begin{columns}
\begin{column}{0.3\textwidth}
  \bit
      \item a package to align short read in R!
      \item If you have a session on vuori you can try that code slightly modified in the R file to use only chromosome 1
  \eit
  \end{column}
  
\begin{column}{0.6\textwidth}
 \begin{uncoverenv}
<<eval=FALSE>>=
## write the human genome sequences
writeXStringSet(Reduce(append,
lapply(seqnames(Hsapiens),
function(nam)
{dss<-DNAStringSet(unmasked(Hsapiens[[nam]]))
names(dss)<-nam
dss})),file="hg19.fa")

##create the indexes
require(Rsubread)
dir.create("indexes")
buildindex(basename=file.path("indexes","hg19"),
           reference="hg19.fa")


## align the reads
sapply(dir(pattern="*\\.gz$"),function(fil){ 
  ## decomplress the files
  gunzip(fil)
  ##align
  align(index=file.path("indexes","hg19"),
        readfile1=sub("\\.gz$","",fil),
        nsubreads=2, TH1=1,
        output_file=sub("\\.fastq\\.gz$","\\,sam",fil))
  ## create bam files
  asBAM(file=sib("\\.fastq\\.gz$","\\.sam",fil),
        destination=sub("\\.fastq\\.gz$","",fil),
        indexDestination=TRUE)
  })
@
       \end{uncoverenv} 
  \end{column}
\end{columns}
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}
\frametitle{easyRNASeq package}
\begin{column}{0.8\textwidth}
      \begin{figure}[ht]
      \centering
      \includegraphics[width=60mm]{diagramas/Seleccio_013.png}
      \end{figure}
  \end{column}
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}
\begin{columns}
\begin{column}{0.6\textwidth}
\frametitle{Replicate comparison}
  \bit
      \item The simplest output is a matrix
        \bit
            \item Comparing replicates is therefore easy
            \item Can be done automatically if the user provides the sample information
            \item GRAFIC
        \eit
  \eit
  \end{column}
\begin{column}{0.6\textwidth}
      \begin{figure}[ht]
      \centering
      \includegraphics[width=40mm]{diagramas/Seleccio_014.png}
      \end{figure}
\end{column}
\end{columns}
\end{frame}

%--------------------------------------------------------------------------------------------------------------------------------

\begin{frame}
\frametitle{Normalization}
\begin{columns}
\begin{column}{0.6\textwidth}
  \bit
      \item Three types can be applied
        \bit
            \item \textbf{R}eads \textbf{P}er feature \textbf{K}b per \textbf{M}ilion reads in the library
        \eit
      \item DESeq
        \bit
            \item based on Negative Binomial
            \item fit a model to correct for the library sizes
        \eit
      \item edgeR
        \bit
            \item based on Negative Binomial
            \item use a trimmed mean og M-values to correct for the library sizes
        \eit
  \eit
  \end{column}

\begin{column}{0.6\textwidth}
      \begin{figure}[ht]
      \centering
      \includegraphics[width=50mm]{diagramas/Seleccio_015.png}
      \end{figure}
\end{column}
\end{columns}
\end{frame}
\end{document}
